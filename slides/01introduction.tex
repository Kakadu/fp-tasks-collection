\documentclass{beamer}
\usetheme{CambridgeUS}
\beamertemplatenavigationsymbolsempty % remove navigation bar

\usepackage{xcolor}
\definecolor{YellowGreen} {HTML}{B5C28C}
\definecolor{ForestGreen} {HTML}{009B55}
\definecolor{MyBackground}{HTML}{F0EDAA}


\usepackage{xltxtra} % load xunicode
\usepackage{polyglossia}
\setmainlanguage{russian}
\setotherlanguage{english}

\let\cyrillicfonttt\monofamily
\newfontfamily\dejaVuSansMono{DejaVu Sans Mono}
% https://github.com/vjpr/monaco-bold/raw/master/MonacoB/MonacoB.otf
\newfontfamily\monacoB{MonacoB}

\usepackage{listings}
\lstdefinestyle{style1}{
  language=haskell,
  numbers=left,
  stepnumber=1,
  numbersep=10pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false
}
\lstdefinestyle{hsstyle1}
{ language=haskell
         , basicstyle=\monacoB
         , deletekeywords={Int,Float,String,List,Void}
         , breaklines=true
         , columns=fullflexible
         , commentstyle=\color{ForestGreen}
         , escapeinside=§§
         , escapebegin=\begin{russian}\commentfont
         , escapeend=\end{russian}
         , commentstyle=\color{ForestGreen}
         , escapeinside=§§
         , escapebegin=\begin{russian}\monacoB\color{ForestGreen}
         , escapeend=\end{russian}
         , mathescape=true
%          , backgroundcolor = \color{MyBackground}
}

\newcommand{\inline}[1]{\lstinline{haskell}{#1}}
\def\hsinline{\lstinline[style={hsstyle1}]}
\def\inline{\hsinline}

\lstnewenvironment{hslisting} {
    \lstset { style={hsstyle1} }
  }
  {}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\setmainfont[
 Ligatures=TeX,
 Extension=.otf,
 BoldFont=cmunbx,
 ItalicFont=cmunti,
 BoldItalicFont=cmunbi,
]{cmunrm}
% С засечками (для заголовков)
\setsansfont[
 Ligatures=TeX,
 Extension=.otf,
 BoldFont=cmunsx,
 ItalicFont=cmunsi,
]{cmunss}
% \setmonofont[Scale=0.6]{Monaco}

\usefonttheme{professionalfonts}
\usepackage{times}
\usepackage{tikz}
\usetikzlibrary{cd}
% \usepackage{tikz-cd}
\usepackage{amsmath}
%\DeclareMathOperator{->}{\rightarrow}
\newcommand\iso{\ensuremath{\cong}}
\usepackage{verbatim}
\usepackage{graphicx}
\usetikzlibrary{arrows,shapes}

\usepackage{fontawesome}
% \newfontfamily{\FA}{Font Awesome 5 Free} % some glyphs missing
\expandafter\def\csname faicon@facebook\endcsname{{\FA\symbol{"F09A}}}
\def\faQuestionSign{{\FA\symbol{"F059}}}
\def\faQuestion{{\FA\symbol{"F128}}}
\def\faExclamation{{\FA\symbol{"F12A}}}
\def\faUploadAlt{{\FA\symbol{"F093}}}
\def\faLemon{{\FA\symbol{"F094}}}
\def\faPhone{{\FA\symbol{"F095}}}
\def\faCheckEmpty{{\FA\symbol{"F096}}}
\def\faBookmarkEmpty{{\FA\symbol{"F097}}}

\newcommand{\faGood}{\textcolor{ForestGreen}{\faThumbsUp}}
\newcommand{\faBad}{\textcolor{red}{\faThumbsODown}}

\usepackage{soul} % for \st that strikes through
\usepackage[normalem]{ulem} % \sout

% \usepackage{minted}
% \newcommand{\inline}[1]{\mintinline{haskell}{#1}}

\title[Part of thesis title]{Функциональщина}
\author{Kakadu}

\institute{St Petersburg University}

\date{\today}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\begin{document}
% \maketitle

% For every picture that defines or uses external nodes, you'll have to
% apply the 'remember picture' style. To avoid some typing, we'll apply
% the style to all pictures.
\tikzstyle{every picture}+=[remember picture]

% By default all math in TikZ nodes are set in inline mode. Change this to
% displaystyle so that we don't get small fractions.
\everymath{\displaystyle}

% Uncomment these lines for an automatically generated outline.
% \begin{frame}{Outline}
%   \tableofcontents
% \end{frame}

\section{Типы}

\begin{frame}[fragile]{А что такое тип?}
% \pause
~\ Ну, если $x$ принадлежит типу \inline=T=, то \inline=T= определяет, какие значения может принимать $x$.
\\ \vspace{0.5cm} %\pause
~\ \emph{Тип} \inline=T= у $x$ -- это \sout{множество} совокупность значений, которые могут быть у $x$.
\vspace{0.5cm} \\ %\pause
~\  Если \inline=x :: T=, то тип \inline=T= \emph{населен} иксом.
\\ \vspace{0.5cm} %\pause
~\ Если $\nexists$ \inline=x=, таких что \inline=x :: T=, то тип \inline=T= \emph{не населен}.
\end{frame}

\begin{frame}[fragile]{Синтаксис типов в Haskell (1/2)}
~\ \emph{Тип функции}, действующей из аргумента типа \hsinline{A} и возвращающей результат \hsinline{B}, обозначается как \hsinline{A->B}.
\\ \pause
~\ Функции, у которых $n$ аргументов ($n>1$) моделируются как функции возвращающие функцию от $n-1$ аргументов. Например, \hsinline{A->(B->C)}. \\
\pause 
\vspace{1cm}
Ассоциативность правая:
\begin{hslisting}
A -> (B -> C) 
\end{hslisting}
то же самое, что и
\begin{hslisting}
A -> B -> C
\end{hslisting}
\end{frame}


\begin{frame}{Синтаксис типов в Haskell (2/2)}
~\ \emph{Параметрический полиморфизм} -- когда один и тот же код, работает для разных типов
(generics в Java/C\#).
\\
~\ Ещё бывает \emph{ad-hoc полиморфизм} -- работает разный код для разных типов (overloading в С++). Но это потом.
\\
~\ \emph{Типовые переменные} в типах полиморфных функций пишутся с маленькой буквы. Например, \inline{a -> b} или \inline{a -> b -> c} или 
\inline=a -> (a -> b) $ $ -> b=
\vspace{0.5cm} 
\\ \pause
~\ \emph{Имена типов} пишутся с заглавной буквы. Например,  \inline=Int=, \inline=String=, \inline=Float=.
\vspace{0.5cm} 
\\ \pause
~\ \emph{Типы с параметрами}: \inline=List Int=, \inline=List String=, \inline=List a=, и т.д. 
\vspace{0.5cm} 
\\ \pause
~\ Когда какое-то имя \emph{типизируется как}(\emph{имеет тип}) \inline=T=, то это записывают так: \inline=x :: T=.
\end{frame}

\begin{frame}[fragile]{Примеры параметрического полиморфизма}
\begin{hslisting}
Prelude> let id x = x
Prelude> :t id
id :: p -> p
\end{hslisting}
\pause
\begin{hslisting}
Prelude> :t (id :: String -> String)
(id :: String -> String) :: String -> String
\end{hslisting}
\pause
\begin{hslisting}
Prelude> :t (id :: Int -> Int)
(id :: Int -> Int) :: Int -> Int
\end{hslisting}
{\Large \faQuestion} Каков \textit{наиболее общий тип} для \inline=id=?
\end{frame}

\begin{frame}[fragile]{Примеры типов}
Тип, который не населен
\begin{hslisting}
Prelude> :i Data.Void.Void
data Data.Void.Void        -- Defined in 'Data.Void'
\end{hslisting}

Тип, у которого только один житель
\begin{hslisting}
Prelude> :i ()
data () = ()               -- Defined in 'GHC.Tuple'
Prelude> :t ()
() :: ()
\end{hslisting}
\end{frame}

\begin{frame}[fragile]{Как ведет себя функция с типом}

{\Large \faQuestion} \hsinline=Void -> Int= \\
\vspace{0.5cm}
{\Large \faQuestion} \hsinline=()  -> Int= \\
\vspace{0.5cm}
{\large \faQuestion} \hsinline=a -> ()= \\
\vspace{0.5cm}
\pause
Ответ:
\begin{hslisting}
unit x = ()
{- §а лучше§ -}
unit _ = ()
\end{hslisting}
\end{frame}

\begin{frame}[fragile]{Тип пары (Декартово произведение)}
\begin{center}
\begin{tikzpicture}[commutative diagrams/every diagram]
\node (P1) at (90:0cm) {\inline=(a,b)=};
\node (P2) at (90+ 90+35:2cm) {\inline=a=};
\node (P3) at (90+270-35:2cm) {\inline=b=};
\path[commutative diagrams/.cd, every arrow, every label]
(P1) edge node[swap] {\inline=fst=} (P2)
(P1) edge node[swap] {\inline=snd=} (P3)
;
\end{tikzpicture}
\end{center}
\pause
Определим \textit{проекции}:
\begin{hslisting}
Prelude> let fst (x,_) = x
Prelude> :t fst
fst :: (a, b) -> a

Prelude> let snd (_,y) = y
Prelude> :t snd
snd :: (a, b) -> b
\end{hslisting}

\end{frame}

\begin{frame}[fragile]{Произведение (product)}
\begin{center}
\begin{tikzpicture}[commutative diagrams/every diagram]
\node (P0) at (90:2.3cm) {\inline=product?=};
\node (P1) at (90:0cm) {$(a,b)$};
\node (P2) at (90+ 90+35:3cm) {\inline=a=};
\node (P3) at (90+270-35:3cm) {\inline=b=};
\path[commutative diagrams/.cd, every arrow, every label]
(P0) edge node[swap] {\mbox{\Large $\exists!$} \inline=m=} (P1)
(P1) edge node[swap] {\inline=fst=} (P2)
(P1) edge node[swap] {\inline=snd=} (P3)
(P0) edge[bend right] node[swap] {\inline=fst2=} (P2)
(P0) edge[bend left]  node[swap] {\inline=snd2=} (P3)
;
\end{tikzpicture}
\end{center}
\begin{hslisting}
fst2 = m . fst
snd2 = m . snd
\end{hslisting}
\end{frame}

% https://repl.it/languages/haskell

\end{document}
